# Architecture Decision Record 001

2026-01-26

---

## 1. 배경

마이크로서비스 아키텍처(MSA) 기반 시스템을 목표로 한다.

주요 관심사는 주문 및 결제 도메인에서 동시성 제어, 일관성, 멱등성이지만,

이러한 기술적 문제를 다루기 위해서는 사용자나 서비스 등 요청 주체의 정체성을 신뢰할 수 있는 방식으로 확보하는 구조가 먼저 필요하다.

모놀리스 아키텍처와 달리, MSA 환경에서는 다음과 같은 문제가 발생한다.

- 각 서비스가 사용자를 직접 인증할 수 없음
- 단일 요청이 다수의 서비스로 전파될 수 있음

## 2. 문제 정의

1. MSA 환경에서 사용자 인증(Authentication)을 어디에서 처리하는가?
2. 인증 결과를 다른 서비스로 어떻게 안전하게 전파할 것인가?
    - 요청을 처리하기 위해 여러 마이크로서비스를 오케스트레이션 해야하는 상황에서 사용자 맥락이 필요한 경우라면?

## 3. 고려한 옵션

1. 각 마이크로서비스가 직접 인증하기
    - 각 서비스가 사용자 DB나 인증 API를 직접 호출
        - 사용자 모델이 중복된다
        - 인증 로직 변경에 대한 유지보수 비용이 너무 크다

2. Gateway에서 토큰 검증하기
    - Gateway를 우회해서 들어오는 내부 서비스 요청에 대해서 어떻게 방어할까?
    -

3. 인증만 담당하는 서비스 만들기 + JWT 인증
    - 인증 결과는 토큰 서명해서 전달
    - 서비스는 토큰 검증해서 사용자 식별

> 3번으로 진행함

## 4. 결정 (Decision)

### 4.1 Identity Service를 별도의 마이크로서비스로 도입한다

Identity Service는 다음 책임만을 가진다.

- 사용자 회원가입 및 인증 정보 관리
- 로그인 성공 시 Access Token 발급
- 토큰 검증을 위한 공개키(JWKS) 제공

---

### 4.2 인증 결과는 JWT로 표현한다

- 인증 결과는 서버 세션이 아닌 **JWT(JSON Web Token)** 로 표현한다.
- 토큰은 stateless 하며, 서비스 간 전달이 가능하다.
- 서비스는 토큰 자체를 신뢰하지 않고, **서명 검증을 통해 신뢰를 형성**한다.

JWT는 “권한 판단 로직”이 아니라,
**“누가 요청했는가”에 대한 증명 수단**으로만 사용한다.

---

### 4.3 RS256 + JWKS 방식을 사용한다

#### 선택 이유

- HS256(shared secret)은 서비스 수가 증가할수록 secret 관리가 어려워짐
- RS256은 private key를 Identity Service에만 두고,
  나머지는 public key로 검증 가능

#### 구조

- Identity Service
    - private key 보관
    - JWT 서명
    - JWKS endpoint 제공
- API Gateway / 각 마이크로서비스
    - JWKS 조회
    - JWT 서명 및 만료 검증

이를 통해 다음을 달성한다.

- 서비스 간 secret 공유 제거
- 키 로테이션 가능성 확보
- 인증 책임의 명확한 경계 설정

---

### 4.4 인증과 인가를 명확히 분리한다

본 프로젝트에서의 역할 분리는 다음과 같다.

| 구분               | 책임                      |
|------------------|-------------------------|
| Identity Service | 인증(Authentication)      |
| API Gateway      | 토큰 검증 + 라우트 레벨 접근 제어    |
| 각 마이크로서비스        | 자원 단위 인가(Authorization) |

각 마이크로서비스는 다음 정보만 사용한다.

- `sub` (요청 주체 식별자)
- 필요 시 `scope` 등 최소 claim

서비스는 사용자 “존재 여부”나 “전역 권한 모델”을 알지 않는다.  
오직 **자신의 도메인 데이터와 요청 주체의 관계**만 판단한다.